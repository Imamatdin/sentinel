"""
PoCGenerator — Generate deterministic replay scripts from exploit results.

Outputs:
- Python script
- Bash (curl) script
- Postman collection JSON
- Machine-readable attack graph
"""
from dataclasses import dataclass


@dataclass
class ReplayArtifact:
    python_script: str
    bash_script: str
    postman_collection: dict
    attack_graph_json: dict


class PoCGenerator:
    """Generates reproducible PoC artifacts from exploit HTTP traces."""

    def generate(self, findings: list, engagement_id: str) -> ReplayArtifact:
        python_lines = [
            "#!/usr/bin/env python3",
            f'"""Sentinel PoC Replay — Engagement {engagement_id}"""',
            "import requests",
            "import sys",
            "",
            "session = requests.Session()",
            "session.verify = False",
            "",
        ]

        bash_lines = [
            "#!/bin/bash",
            f"# Sentinel PoC Replay — Engagement {engagement_id}",
            "set -e",
            "",
        ]

        postman_items = []
        graph_nodes = []

        for i, finding in enumerate(findings):
            traces = finding.get("http_traces", [])
            for j, trace in enumerate(traces):
                step_name = f"Step {i+1}.{j+1}: {finding.get('category', 'unknown')}"

                # Python
                python_lines.append(f"# {step_name}")
                method = trace.get("method", "GET").lower()
                python_lines.append(f"response = session.{method}(")
                python_lines.append(f'    "{trace.get("url", "")}",')
                if trace.get("headers"):
                    python_lines.append(f"    headers={trace['headers']},")
                if trace.get("body"):
                    python_lines.append(f'    data="""{trace["body"]}""",')
                python_lines.append(")")
                python_lines.append(f'print(f"[{step_name}] Status: {{response.status_code}}")')
                python_lines.append("")

                # Bash
                bash_lines.append(f'echo "=== {step_name} ==="')
                curl_cmd = (
                    f'curl -s -o /dev/null -w "%{{http_code}}"'
                    f' -X {trace.get("method", "GET")} "{trace.get("url", "")}"'
                )
                for k, v in trace.get("headers", {}).items():
                    curl_cmd += f' -H "{k}: {v}"'
                if trace.get("body"):
                    curl_cmd += f" -d '{trace['body']}'"
                bash_lines.append(curl_cmd)
                bash_lines.append("")

                # Postman
                body_raw = trace.get("body", "")
                postman_items.append(
                    {
                        "name": step_name,
                        "request": {
                            "method": trace.get("method", "GET"),
                            "url": {"raw": trace.get("url", "")},
                            "header": [
                                {"key": k, "value": v}
                                for k, v in trace.get("headers", {}).items()
                            ],
                            "body": {"mode": "raw", "raw": body_raw} if body_raw else None,
                        },
                    }
                )

                # Graph node
                graph_nodes.append(
                    {
                        "step": f"{i+1}.{j+1}",
                        "category": finding.get("category"),
                        "target": trace.get("url"),
                        "method": trace.get("method"),
                        "evidence": finding.get("evidence", "")[:200],
                    }
                )

        return ReplayArtifact(
            python_script="\n".join(python_lines),
            bash_script="\n".join(bash_lines),
            postman_collection={
                "info": {
                    "name": f"Sentinel PoC — {engagement_id}",
                    "schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json",
                },
                "item": postman_items,
            },
            attack_graph_json={
                "engagement_id": engagement_id,
                "nodes": graph_nodes,
                "edges": [
                    {"from": f"{i}.1", "to": f"{i+1}.1"} for i in range(len(graph_nodes) - 1)
                ],
            },
        )
