"""
BrowserWorker â€” Playwright-powered browser exploitation.

Handles what scanners can't:
- Single Page Applications (SPA)
- JavaScript-rendered content
- DOM-based XSS
- CSRF token extraction and bypass
- Authentication flows (login, OAuth, MFA)
- Session management testing
- Cookie manipulation
"""
import asyncio
from dataclasses import dataclass, field
from typing import Optional

from playwright.async_api import async_playwright, Page, Browser, BrowserContext

from sentinel.tools.base import ToolOutput
from sentinel.logging_config import get_logger

logger = get_logger(__name__)


@dataclass
class BrowserSession:
    context: BrowserContext
    page: Page
    cookies: list = field(default_factory=list)
    local_storage: dict = field(default_factory=dict)
    session_tokens: list = field(default_factory=list)


class BrowserWorker:
    """
    Playwright-based browser automation for web exploitation.

    Capabilities:
    - Navigate and interact with SPAs
    - Execute JavaScript in page context
    - Monitor network requests/responses
    - Detect DOM mutations
    - Handle authentication flows
    - Extract tokens, cookies, session data
    - Test DOM XSS payloads
    - CSRF token extraction and form submission
    """

    name = "browser_worker"
    description = "Playwright browser automation for web app exploitation"

    def __init__(self):
        self._browser: Optional[Browser] = None
        self._playwright = None

    async def start(self, headless: bool = True):
        """Initialize Playwright browser."""
        self._playwright = await async_playwright().start()
        self._browser = await self._playwright.chromium.launch(
            headless=headless,
            args=["--no-sandbox", "--disable-web-security"],
        )
        logger.info("Browser worker started")

    async def stop(self):
        """Cleanup browser resources."""
        if self._browser:
            await self._browser.close()
        if self._playwright:
            await self._playwright.stop()

    async def create_session(self, base_url: str = None) -> BrowserSession:
        """Create a new browser session (isolated context)."""
        context = await self._browser.new_context(
            viewport={"width": 1280, "height": 720},
            ignore_https_errors=True,
        )
        page = await context.new_page()

        if base_url:
            await page.goto(base_url, wait_until="networkidle")

        return BrowserSession(context=context, page=page)

    async def authenticate(
        self,
        session: BrowserSession,
        login_url: str,
        username: str,
        password: str,
        username_selector: str = 'input[name="email"], input[name="username"], input[type="email"]',
        password_selector: str = 'input[name="password"], input[type="password"]',
        submit_selector: str = 'button[type="submit"], input[type="submit"]',
    ) -> ToolOutput:
        """Authenticate via browser form submission."""
        try:
            await session.page.goto(login_url, wait_until="networkidle")
            await session.page.fill(username_selector, username)
            await session.page.fill(password_selector, password)
            await session.page.click(submit_selector)
            await session.page.wait_for_load_state("networkidle")

            # Capture session data
            cookies = await session.context.cookies()
            session.cookies = cookies

            # Check for auth tokens in localStorage
            local_storage = await session.page.evaluate("""() => {
                const data = {};
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    data[key] = localStorage.getItem(key);
                }
                return data;
            }""")
            session.local_storage = local_storage

            # Extract JWT or session tokens
            for cookie in cookies:
                if any(t in cookie["name"].lower() for t in ["token", "session", "jwt", "auth"]):
                    session.session_tokens.append(cookie["value"])

            for key, value in local_storage.items():
                if any(t in key.lower() for t in ["token", "jwt", "auth"]):
                    session.session_tokens.append(value)

            return ToolOutput(
                success=len(session.session_tokens) > 0 or len(cookies) > 0,
                data={
                    "cookies": cookies,
                    "tokens": session.session_tokens,
                    "local_storage_keys": list(local_storage.keys()),
                    "final_url": session.page.url,
                },
                tool_name=self.name,
            )
        except Exception as e:
            return ToolOutput(
                success=False,
                data={},
                error=str(e),
                tool_name=self.name,
            )

    async def test_dom_xss(
        self,
        session: BrowserSession,
        target_url: str,
        param_name: str,
    ) -> ToolOutput:
        """Test for DOM-based XSS by injecting payloads and checking DOM mutations."""
        findings = []

        payloads = [
            '<img src=x onerror="window.__sentinel_xss=true">',
            '<svg onload="window.__sentinel_xss=true">',
            '"><script>window.__sentinel_xss=true</script>',
            "'-alert(1)-'",
            "javascript:window.__sentinel_xss=true",
            '{{constructor.constructor("window.__sentinel_xss=true")()}}',
            "${window.__sentinel_xss=true}",
        ]

        for payload in payloads:
            try:
                separator = "&" if "?" in target_url else "?"
                test_url = f"{target_url}{separator}{param_name}={payload}"

                await session.page.goto(test_url, wait_until="networkidle")
                await asyncio.sleep(1)

                xss_fired = await session.page.evaluate("() => window.__sentinel_xss === true")

                if xss_fired:
                    findings.append(
                        {
                            "payload": payload,
                            "url": test_url,
                            "type": "DOM XSS",
                            "evidence": "JavaScript execution confirmed via window.__sentinel_xss flag",
                        }
                    )
                    await session.page.evaluate("() => { window.__sentinel_xss = false; }")
                    logger.info(f"DOM XSS confirmed with payload: {payload[:50]}...")

            except Exception as e:
                logger.debug(f"DOM XSS test failed for payload: {e}")

        return ToolOutput(
            success=len(findings) > 0,
            data={"findings": findings},
            tool_name=self.name,
        )

    async def extract_csrf_token(self, session: BrowserSession, form_url: str) -> Optional[str]:
        """Extract CSRF token from a page."""
        await session.page.goto(form_url, wait_until="networkidle")

        selectors = [
            'input[name="csrf"], input[name="_csrf"]',
            'input[name="csrfmiddlewaretoken"]',
            'input[name="authenticity_token"]',
            'meta[name="csrf-token"]',
        ]

        for selector in selectors:
            element = await session.page.query_selector(selector)
            if element:
                value = await element.get_attribute("value") or await element.get_attribute("content")
                if value:
                    return value

        return None

    async def capture_dom_state(self, session: BrowserSession) -> dict:
        """Capture full DOM state for graph analysis."""
        return await session.page.evaluate("""() => {
            const forms = Array.from(document.forms).map(f => ({
                action: f.action,
                method: f.method,
                inputs: Array.from(f.elements).map(e => ({
                    name: e.name, type: e.type, value: e.value
                }))
            }));
            const links = Array.from(document.links).map(a => a.href);
            const scripts = Array.from(document.scripts).map(s => s.src || 'inline');
            return { forms, links, scripts, title: document.title, url: window.location.href };
        }""")

    async def execute(self, target_url: str, action: str = "capture_state") -> ToolOutput:
        """Generic execute method."""
        session = await self.create_session(target_url)
        try:
            if action == "capture_state":
                state = await self.capture_dom_state(session)
                return ToolOutput(success=True, data=state, tool_name=self.name)
            return ToolOutput(
                success=False,
                data={},
                error=f"Unknown action: {action}",
                tool_name=self.name,
            )
        finally:
            await session.context.close()
