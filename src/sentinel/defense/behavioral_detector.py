"""BehavioralDetector -- ML-based anomaly detection for attack identification.

Replaces regex-only pattern matching with:
- Request frequency analysis (detect brute force, fuzzing)
- Payload entropy analysis (detect encoded/obfuscated attacks)
- Session behavior profiling (detect scanning patterns)
- Response anomaly detection (detect data exfiltration)
"""

import math
from collections import defaultdict, deque
from dataclasses import dataclass, field
from typing import Any

from sentinel.core import get_logger

logger = get_logger(__name__)


@dataclass
class RequestProfile:
    """Profile of a single HTTP request for behavioral analysis."""

    timestamp: float
    source_ip: str
    method: str
    path: str
    params: dict[str, Any]
    headers: dict[str, Any]
    body_size: int
    body_entropy: float
    response_code: int
    response_size: int
    response_time_ms: float


@dataclass
class DetectionAlert:
    """Alert generated by behavioral detection."""

    alert_type: str  # "brute_force", "fuzzing", "sqli", "xss", "data_exfil", "scanning", etc.
    confidence: float  # 0.0-1.0
    source_ip: str
    evidence: str
    mitre_technique: str  # ATT&CK ID
    timestamp: float
    request: RequestProfile | None = None
    recommended_action: str = ""  # "block_ip", "rate_limit", "challenge", "log"


class BehavioralDetector:
    """Real-time behavioral detection engine.

    Maintains per-IP state to detect:
    1. Volumetric attacks (brute force, credential stuffing)
    2. Payload anomalies (high entropy, unusual encoding)
    3. Scanning behavior (sequential endpoint probing)
    4. Injection patterns (SQLi, XSS, command injection, SSRF, XXE)
    5. Data exfiltration (large/unusual responses)
    """

    def __init__(self) -> None:
        # Per-IP request history (sliding window)
        self.ip_history: dict[str, deque] = defaultdict(lambda: deque(maxlen=1000))
        # Per-IP rate counters
        self.ip_rates: dict[str, list[float]] = defaultdict(list)
        # Thresholds
        self.rate_limit_per_second = 10
        self.rate_limit_per_minute = 100
        self.entropy_threshold = 4.5  # Shannon entropy for suspicious payloads
        self.scan_pattern_threshold = 20  # Unique paths in 60 seconds

    def analyze_request(self, request: RequestProfile) -> list[DetectionAlert]:
        """Analyze a single request for suspicious behavior."""
        alerts: list[DetectionAlert] = []

        # Track history
        self.ip_history[request.source_ip].append(request)
        self.ip_rates[request.source_ip].append(request.timestamp)

        # 1. Rate-based detection
        rate_alert = self._check_rate(request)
        if rate_alert:
            alerts.append(rate_alert)

        # 2. Payload entropy analysis
        if request.body_entropy > self.entropy_threshold:
            alerts.append(DetectionAlert(
                alert_type="suspicious_payload",
                confidence=min(request.body_entropy / 8.0, 1.0),
                source_ip=request.source_ip,
                evidence=f"High entropy payload: {request.body_entropy:.2f} bits",
                mitre_technique="T1027",  # Obfuscated Files
                timestamp=request.timestamp,
                request=request,
                recommended_action="challenge",
            ))

        # 3. Scanning detection
        scan_alert = self._check_scanning(request)
        if scan_alert:
            alerts.append(scan_alert)

        # 4. SQLi/XSS/injection pattern detection
        injection_alert = self._check_injection_patterns(request)
        if injection_alert:
            alerts.append(injection_alert)

        # 5. Data exfiltration detection
        if request.response_size > 100_000:  # 100KB+
            alerts.append(DetectionAlert(
                alert_type="data_exfil",
                confidence=0.6,
                source_ip=request.source_ip,
                evidence=f"Large response: {request.response_size} bytes",
                mitre_technique="T1041",  # Exfiltration Over C2 Channel
                timestamp=request.timestamp,
                request=request,
                recommended_action="log",
            ))

        return alerts

    def _check_rate(self, request: RequestProfile) -> DetectionAlert | None:
        """Check for rate-based attacks (brute force, fuzzing)."""
        now = request.timestamp
        recent = [t for t in self.ip_rates[request.source_ip] if now - t < 60]
        self.ip_rates[request.source_ip] = recent

        per_second = sum(1 for t in recent if now - t < 1)
        per_minute = len(recent)

        if per_second > self.rate_limit_per_second:
            return DetectionAlert(
                alert_type="brute_force",
                confidence=0.9,
                source_ip=request.source_ip,
                evidence=f"{per_second} requests/sec (limit: {self.rate_limit_per_second})",
                mitre_technique="T1110",  # Brute Force
                timestamp=now,
                request=request,
                recommended_action="block_ip",
            )
        elif per_minute > self.rate_limit_per_minute:
            return DetectionAlert(
                alert_type="fuzzing",
                confidence=0.7,
                source_ip=request.source_ip,
                evidence=f"{per_minute} requests/min (limit: {self.rate_limit_per_minute})",
                mitre_technique="T1595",  # Active Scanning
                timestamp=now,
                request=request,
                recommended_action="rate_limit",
            )
        return None

    def _check_scanning(self, request: RequestProfile) -> DetectionAlert | None:
        """Detect sequential endpoint probing."""
        now = request.timestamp
        recent = [r for r in self.ip_history[request.source_ip] if now - r.timestamp < 60]
        unique_paths = len(set(r.path for r in recent))

        if unique_paths > self.scan_pattern_threshold:
            return DetectionAlert(
                alert_type="scanning",
                confidence=0.8,
                source_ip=request.source_ip,
                evidence=f"{unique_paths} unique paths in 60s",
                mitre_technique="T1595.002",  # Vulnerability Scanning
                timestamp=now,
                request=request,
                recommended_action="rate_limit",
            )
        return None

    def _check_injection_patterns(self, request: RequestProfile) -> DetectionAlert | None:
        """Enhanced injection detection beyond simple regex."""
        suspicious_patterns: dict[str, list[str]] = {
            "sqli": ["' OR ", "UNION SELECT", "1=1", "' AND ", "ORDER BY", "GROUP BY", "--", "/*"],
            "xss": ["<script", "onerror=", "onload=", "javascript:", "alert(", "document.cookie"],
            "cmd_injection": ["; id", "| cat", "`id`", "$(", "& ping"],
            "ssrf": ["169.254.169.254", "metadata.google", "127.0.0.1", "file:///"],
            "xxe": ["<!DOCTYPE", "<!ENTITY", "SYSTEM", "file:///"],
        }

        # Check all request components
        search_text = " ".join([
            request.path,
            str(request.params),
            str(request.headers.get("Cookie", "")),
        ]).lower()

        for category, patterns in suspicious_patterns.items():
            matches = [p for p in patterns if p.lower() in search_text]
            if matches:
                mitre_map = {
                    "sqli": "T1190",
                    "xss": "T1059.007",
                    "cmd_injection": "T1059",
                    "ssrf": "T1090",
                    "xxe": "T1190",
                }
                return DetectionAlert(
                    alert_type=category,
                    confidence=min(0.5 + 0.1 * len(matches), 0.95),
                    source_ip=request.source_ip,
                    evidence=f"Matched patterns: {matches[:3]}",
                    mitre_technique=mitre_map.get(category, "T1190"),
                    timestamp=request.timestamp,
                    request=request,
                    recommended_action="block_ip" if len(matches) > 2 else "challenge",
                )
        return None

    @staticmethod
    def calculate_entropy(data: str) -> float:
        """Calculate Shannon entropy of a string."""
        if not data:
            return 0.0
        freq: dict[str, int] = defaultdict(int)
        for c in data:
            freq[c] += 1
        length = len(data)
        return -sum(
            (count / length) * math.log2(count / length)
            for count in freq.values()
        )
