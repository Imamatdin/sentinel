"""Exploit agent.

The ExploitAgent receives findings from the ReconAgent and attempts to
exploit discovered vulnerabilities. It has access to injection, XSS,
authentication, and IDOR testing tools.

Tools available: http_request, sql_injection_test, xss_test, login_attempt,
                 idor_test, check_challenges
"""

import time
from typing import Any, Optional

from sentinel.agents.base import BaseAgent, AgentResult
from sentinel.events.bus import EventType
from sentinel.logging_config import get_logger

logger = get_logger(__name__)


class ExploitAgent(BaseAgent):
    """Exploitation agent for vulnerability testing.

    Takes recon findings as context and systematically attempts
    exploitation of discovered attack vectors.
    """

    def __init__(self, target_url: str, **kwargs: Any):
        super().__init__(**kwargs)
        self.target_url = target_url

    @property
    def system_prompt(self) -> str:
        return f"""You are SENTINEL's exploitation agent. Your mission is to exploit vulnerabilities in the target application based on reconnaissance findings.

## Target
- URL: {self.target_url}
- Type: Web application (OWASP Juice Shop)

## Objectives
1. Attempt SQL injection on discovered endpoints (search, login, API params)
2. Test for XSS vulnerabilities on user input fields
3. Try default/weak credential login (admin@juice-sh.op, common passwords)
4. Test IDOR on user profiles, orders, and basket endpoints
5. Check challenge scoreboard after each successful exploit

## Attack Priority (highest impact first)
1. SQL injection on login/search for data extraction
2. Authentication bypass with weak credentials
3. IDOR on user data endpoints
4. XSS for session hijacking vectors

## Rules
- Use the recon findings provided in context. Don't repeat reconnaissance.
- After each successful exploit, check the challenge scoreboard.
- Document what worked, what didn't, and why.
- Be creative but systematic. Try multiple payload variations.
- If a WAF blocks you, note the blocked payload and try evasion techniques.

## Output Format
After exploitation is complete, provide:
1. Successful exploits (vulnerability type, endpoint, payload, impact)
2. Failed attempts (what was tried and why it failed)
3. WAF blocks encountered (if any)
4. Juice Shop challenges solved
5. Overall risk assessment"""

    @property
    def tool_schemas(self) -> list[dict[str, Any]]:
        """ExploitAgent gets exploit tools plus http_request and challenges."""
        if self.tool_registry is None:
            return []
        exploit_tools = [
            "http_request", "sql_injection_test", "xss_test",
            "login_attempt", "idor_test", "check_challenges",
        ]
        return self.tool_registry.get_schemas(tool_names=exploit_tools)

    async def run(self, context: Optional[dict[str, Any]] = None) -> AgentResult:
        """Execute exploitation based on recon findings."""
        start_time = time.time()

        logger.info("exploit_starting", target=self.target_url, agent=self.name)

        try:
            user_message = (
                f"Exploit vulnerabilities on {self.target_url} based on the "
                "reconnaissance findings provided below. Prioritize high-impact "
                "attacks: SQL injection, auth bypass, IDOR. Check the challenge "
                "scoreboard after each successful exploit."
            )

            conversation, metrics = await self._run_tool_loop(
                user_message=user_message,
                context=context,
            )

            final_response = self._extract_last_response(conversation)

            findings = {
                "target_url": self.target_url,
                "summary": final_response,
                "tool_calls_made": sum(
                    len(m.tool_calls) for m in conversation if m.tool_calls
                ),
            }

            await self._emit(EventType.RED_FINDING, {
                "agent": self.name,
                "phase": "exploit",
                "findings": findings,
            })

            await self._emit(EventType.RED_PHASE_COMPLETE, {
                "agent": self.name,
                "phase": "exploit",
            })

            logger.info(
                "exploit_complete",
                agent=self.name,
                tool_calls=findings["tool_calls_made"],
                duration=f"{time.time() - start_time:.1f}s",
            )

            return AgentResult(
                agent_name=self.name,
                success=True,
                conversation=conversation,
                metrics=metrics,
                findings=findings,
                start_time=start_time,
                end_time=time.time(),
            )

        except Exception as e:
            logger.error("exploit_failed", agent=self.name, error=str(e))
            await self._emit(EventType.AGENT_ERROR, {
                "agent": self.name,
                "error": str(e),
            })
            return AgentResult(
                agent_name=self.name,
                success=False,
                error=str(e),
                start_time=start_time,
                end_time=time.time(),
            )
