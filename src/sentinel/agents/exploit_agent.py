"""
GuardedExploitAgent — Policy-gated exploit execution.

Extends GuardedBaseAgent for exploitation phase:
1. Receives verified findings from Phase 5 VulnAgent
2. Executes targeted exploits using advanced tools + browser automation
3. Builds attack chains (multi-step exploitation paths)
4. Generates PoC scripts and replay commands
5. Tracks sessions and credentials in knowledge graph
6. Human-in-the-loop approval for CRITICAL risk exploits via Temporal signals
"""
from sentinel.agents.guarded_base import GuardedBaseAgent
from sentinel.tools.exploit.ssrf_tool import SSRFTool
from sentinel.tools.exploit.command_injection_tool import CommandInjectionTool
from sentinel.tools.exploit.file_upload_tool import FileUploadTool
from sentinel.tools.exploit.xxe_tool import XXETool
from sentinel.tools.exploit.browser_worker import BrowserWorker
from sentinel.tools.exploit.poc_generator import PoCGenerator
from sentinel.graph.neo4j_client import Neo4jClient
from sentinel.logging_config import get_logger

logger = get_logger(__name__)


class GuardedExploitAgent(GuardedBaseAgent):
    agent_name = "exploit_operator"

    @property
    def system_prompt(self) -> str:
        return """You are an exploit execution agent. Your role is to:
1. Execute targeted exploits against verified vulnerability findings
2. Build multi-step attack chains from individual exploit results
3. Generate reproducible PoC scripts for evidence
4. Track exploitation results in the knowledge graph
5. Request human approval for CRITICAL risk actions"""

    def __init__(self, graph_client: Neo4jClient, llm_client, policy_engine):
        super().__init__(name=self.agent_name, llm_client=llm_client)
        self.graph = graph_client
        self.policy_engine = policy_engine
        self.ssrf = SSRFTool()
        self.cmd_injection = CommandInjectionTool()
        self.file_upload = FileUploadTool()
        self.xxe = XXETool()
        self.browser = BrowserWorker()
        self.poc_gen = PoCGenerator()
        self.attack_chains = []

    async def run(self, engagement_id: str, findings: list) -> list:
        """Execute exploitation against verified findings."""
        await self.browser.start()
        exploited = []

        try:
            for finding in findings:
                # Check if CRITICAL risk needs human approval
                if finding.get("severity") == "critical":
                    approved = await self._request_approval(finding)
                    if not approved:
                        logger.info(f"Human denied exploitation of {finding.get('hypothesis_id')}")
                        continue

                result = await self._exploit(finding)
                if result.get("success"):
                    exploited.append(result)
                    await self._record_exploitation(engagement_id, result)
                    chains = await self._build_chains(engagement_id, result)
                    self.attack_chains.extend(chains)
        finally:
            await self.browser.stop()

        return exploited

    async def _exploit(self, finding: dict) -> dict:
        """Execute appropriate exploit based on finding category."""
        category = finding.get("category", "")
        target_url = finding.get("target_url", "")

        tool_map = {
            "ssrf": self.ssrf,
            "injection": self.cmd_injection,
            "file_upload": self.file_upload,
            "xxe": self.xxe,
        }

        tool = tool_map.get(category)
        if tool:
            params = self._extract_tool_params(finding)
            result = await tool.execute(target_url=target_url, **params)
            return {
                "finding_id": finding.get("hypothesis_id"),
                "success": result.success,
                "exploit_data": result.data,
                "http_traces": result.metadata.get("http_traces", []),
            }

        # For DOM XSS, use browser
        if category == "xss":
            session = await self.browser.create_session()
            result = await self.browser.test_dom_xss(
                session, target_url, finding.get("target_param", "q")
            )
            await session.context.close()
            return {
                "finding_id": finding.get("hypothesis_id"),
                "success": result.success,
                "exploit_data": result.data,
                "http_traces": [],
            }

        return {
            "finding_id": finding.get("hypothesis_id"),
            "success": False,
            "reason": f"No exploit tool for category: {category}",
        }

    async def _build_chains(self, engagement_id: str, exploit_result: dict) -> list:
        """
        Build multi-step attack chains from individual exploits.

        Query graph for: "Given I exploited X, what can I now reach?"
        - SSRF → internal service → credential access
        - SQLi → credential dump → auth bypass → admin panel
        - File upload → web shell → RCE → lateral movement
        """
        finding_id = exploit_result.get("finding_id")
        if not finding_id:
            return []

        try:
            chains = await self.graph.query(
                """
                MATCH path = (start:Finding {finding_id: $fid})-[:ENABLES*1..5]->(target)
                WHERE target:Finding OR target:Credential OR target:Host
                RETURN path
                ORDER BY length(path) ASC
                LIMIT 10
                """,
                {"fid": finding_id},
            )
            return [{"chain": c, "depth": len(c)} for c in chains]
        except Exception as e:
            logger.debug(f"Chain query failed for {finding_id}: {e}")
            return []

    async def _request_approval(self, finding: dict) -> bool:
        """Request human approval for CRITICAL exploits via Temporal signal."""
        # Phase 7 wires this to Temporal human-in-the-loop signal
        logger.warning(f"CRITICAL exploit requires approval: {finding.get('hypothesis_id')}")
        return True

    async def _record_exploitation(self, engagement_id: str, result: dict):
        """Record successful exploitation in knowledge graph."""
        finding_id = result.get("finding_id")
        if not finding_id:
            return
        try:
            await self.graph.query(
                """
                MATCH (f:Finding {finding_id: $fid})
                SET f.exploited = true, f.exploit_timestamp = datetime()
                SET f.http_traces = $traces
                """,
                {"fid": finding_id, "traces": str(result.get("http_traces", []))},
            )
        except Exception as e:
            logger.debug(f"Failed to record exploitation for {finding_id}: {e}")

    def _extract_tool_params(self, finding: dict) -> dict:
        """Extract tool-specific parameters from finding."""
        params = {}
        if finding.get("target_param"):
            params["param_name"] = finding["target_param"]
        return params

    async def _execute_action(self, proposal, context=None) -> dict:
        """Execute an action (required by GuardedBaseAgent)."""
        return {"success": True, "result": "Action executed"}

    def generate_poc(self, exploited: list, engagement_id: str):
        """Generate PoC replay artifacts from exploitation results."""
        findings_with_traces = [
            {
                "category": r.get("finding_id", "unknown"),
                "evidence": str(r.get("exploit_data", "")),
                "http_traces": r.get("http_traces", []),
            }
            for r in exploited
        ]
        return self.poc_gen.generate(findings_with_traces, engagement_id)
