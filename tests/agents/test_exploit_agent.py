"""Tests for GuardedExploitAgent."""
import pytest
from unittest.mock import AsyncMock, MagicMock, patch


class TestGuardedExploitAgent:
    def setup_method(self):
        # Mock all dependencies to avoid actual network/LLM calls
        self.mock_graph = AsyncMock()
        self.mock_llm = AsyncMock()
        self.mock_policy = AsyncMock()

        with (
            patch("sentinel.agents.exploit_agent.SSRFTool"),
            patch("sentinel.agents.exploit_agent.CommandInjectionTool"),
            patch("sentinel.agents.exploit_agent.FileUploadTool"),
            patch("sentinel.agents.exploit_agent.XXETool"),
            patch("sentinel.agents.exploit_agent.BrowserWorker"),
        ):
            from sentinel.agents.exploit_agent import GuardedExploitAgent

            self.agent = GuardedExploitAgent(
                graph_client=self.mock_graph,
                llm_client=self.mock_llm,
                policy_engine=self.mock_policy,
            )

    def test_agent_name(self):
        from sentinel.agents.exploit_agent import GuardedExploitAgent

        assert GuardedExploitAgent.agent_name == "exploit_operator"

    def test_policy_engine_stored(self):
        assert self.agent.policy_engine is self.mock_policy

    def test_graph_stored(self):
        assert self.agent.graph is self.mock_graph

    def test_system_prompt_defined(self):
        prompt = self.agent.system_prompt
        assert isinstance(prompt, str)
        assert len(prompt) > 20

    @pytest.mark.asyncio
    async def test_run_empty_findings_returns_empty_list(self):
        self.agent.browser.start = AsyncMock()
        self.agent.browser.stop = AsyncMock()

        result = await self.agent.run("eng-001", [])
        assert result == []

    @pytest.mark.asyncio
    async def test_run_skips_critical_when_denied(self):
        self.agent.browser.start = AsyncMock()
        self.agent.browser.stop = AsyncMock()
        self.agent._request_approval = AsyncMock(return_value=False)

        finding = {
            "hypothesis_id": "hyp-1",
            "severity": "critical",
            "category": "ssrf",
            "target_url": "http://target/api",
        }
        result = await self.agent.run("eng-001", [finding])
        assert result == []
        self.agent._request_approval.assert_called_once()

    @pytest.mark.asyncio
    async def test_exploit_unknown_category_returns_failure(self):
        finding = {
            "hypothesis_id": "hyp-x",
            "category": "unknown_category",
            "target_url": "http://target/",
        }
        result = await self.agent._exploit(finding)
        assert result["success"] is False
        assert "No exploit tool" in result["reason"]

    @pytest.mark.asyncio
    async def test_exploit_ssrf_category_calls_ssrf_tool(self):
        mock_tool_output = MagicMock()
        mock_tool_output.success = True
        mock_tool_output.data = {"findings": [{"payload": "aws"}]}
        mock_tool_output.metadata = {"http_traces": []}

        self.agent.ssrf.execute = AsyncMock(return_value=mock_tool_output)

        finding = {
            "hypothesis_id": "hyp-ssrf",
            "category": "ssrf",
            "target_url": "http://target/fetch",
            "target_param": "url",
        }
        result = await self.agent._exploit(finding)
        assert result["success"] is True
        assert result["finding_id"] == "hyp-ssrf"
        self.agent.ssrf.execute.assert_called_once()

    @pytest.mark.asyncio
    async def test_exploit_xss_uses_browser(self):
        mock_output = MagicMock()
        mock_output.success = True
        mock_output.data = {"findings": [{"type": "DOM XSS"}]}

        mock_session = AsyncMock()
        mock_session.context = AsyncMock()
        self.agent.browser.create_session = AsyncMock(return_value=mock_session)
        self.agent.browser.test_dom_xss = AsyncMock(return_value=mock_output)

        finding = {
            "hypothesis_id": "hyp-xss",
            "category": "xss",
            "target_url": "http://target/search",
            "target_param": "q",
        }
        result = await self.agent._exploit(finding)
        assert result["success"] is True
        self.agent.browser.test_dom_xss.assert_called_once()

    @pytest.mark.asyncio
    async def test_build_chains_returns_empty_on_error(self):
        self.mock_graph.query = AsyncMock(side_effect=Exception("Neo4j unavailable"))
        result = await self.agent._build_chains("eng-1", {"finding_id": "hyp-1"})
        assert result == []

    @pytest.mark.asyncio
    async def test_build_chains_returns_empty_when_no_finding_id(self):
        result = await self.agent._build_chains("eng-1", {})
        assert result == []

    @pytest.mark.asyncio
    async def test_record_exploitation_calls_graph(self):
        self.mock_graph.query = AsyncMock(return_value=[])
        await self.agent._record_exploitation("eng-1", {"finding_id": "hyp-1", "http_traces": []})
        self.mock_graph.query.assert_called_once()

    @pytest.mark.asyncio
    async def test_record_exploitation_silent_on_error(self):
        self.mock_graph.query = AsyncMock(side_effect=Exception("DB error"))
        # Should not raise
        await self.agent._record_exploitation("eng-1", {"finding_id": "hyp-1"})

    def test_extract_tool_params_with_target_param(self):
        finding = {"hypothesis_id": "h", "category": "ssrf", "target_param": "url"}
        params = self.agent._extract_tool_params(finding)
        assert params == {"param_name": "url"}

    def test_extract_tool_params_without_target_param(self):
        finding = {"hypothesis_id": "h", "category": "ssrf"}
        params = self.agent._extract_tool_params(finding)
        assert params == {}

    def test_generate_poc(self):
        exploited = [
            {
                "finding_id": "hyp-1",
                "success": True,
                "exploit_data": {"findings": []},
                "http_traces": [{"method": "GET", "url": "http://t/1", "headers": {}, "body": ""}],
            }
        ]
        artifact = self.agent.generate_poc(exploited, "eng-123")
        assert "import requests" in artifact.python_script
        assert "curl" in artifact.bash_script
