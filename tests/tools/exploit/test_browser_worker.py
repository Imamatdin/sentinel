"""Tests for BrowserWorker â€” mocked to avoid requiring Playwright install."""
import pytest
from unittest.mock import AsyncMock, MagicMock, patch

from sentinel.tools.exploit.browser_worker import BrowserWorker, BrowserSession


class TestBrowserWorker:
    def setup_method(self):
        self.worker = BrowserWorker()

    def test_tool_name(self):
        assert self.worker.name == "browser_worker"

    def test_initial_state(self):
        assert self.worker._browser is None
        assert self.worker._playwright is None

    @pytest.mark.asyncio
    async def test_start_stop(self):
        """Verify start/stop lifecycle with mocked Playwright."""
        mock_browser = AsyncMock()
        mock_playwright_instance = AsyncMock()
        mock_playwright_instance.chromium.launch = AsyncMock(return_value=mock_browser)

        with patch(
            "sentinel.tools.exploit.browser_worker.async_playwright"
        ) as mock_pw:
            mock_pw.return_value.start = AsyncMock(return_value=mock_playwright_instance)
            await self.worker.start(headless=True)
            assert self.worker._browser is not None
            assert self.worker._playwright is not None

            await self.worker.stop()
            mock_browser.close.assert_called_once()
            mock_playwright_instance.stop.assert_called_once()

    @pytest.mark.asyncio
    async def test_create_session_returns_browser_session(self):
        """create_session returns a BrowserSession with page and context."""
        mock_page = AsyncMock()
        mock_context = AsyncMock()
        mock_context.new_page = AsyncMock(return_value=mock_page)

        mock_browser = AsyncMock()
        mock_browser.new_context = AsyncMock(return_value=mock_context)
        self.worker._browser = mock_browser

        session = await self.worker.create_session()
        assert isinstance(session, BrowserSession)
        assert session.page is mock_page
        assert session.context is mock_context

    @pytest.mark.asyncio
    async def test_dom_xss_no_finding_when_flag_false(self):
        """DOM XSS test returns no findings when JS flag not set."""
        mock_page = AsyncMock()
        mock_page.goto = AsyncMock()
        mock_page.evaluate = AsyncMock(return_value=False)

        mock_context = AsyncMock()
        session = BrowserSession(context=mock_context, page=mock_page)

        result = await self.worker.test_dom_xss(session, "http://target/page", "q")
        assert result.success is False
        assert result.data["findings"] == []

    @pytest.mark.asyncio
    async def test_dom_xss_finds_vulnerability_when_flag_true(self):
        """DOM XSS test returns finding when JS execution confirmed."""
        call_count = 0

        async def mock_evaluate(js):
            nonlocal call_count
            call_count += 1
            # First call: flag=True (XSS fired), subsequent: False (reset)
            if call_count == 1:
                return True
            return False

        mock_page = AsyncMock()
        mock_page.goto = AsyncMock()
        mock_page.evaluate = mock_evaluate

        mock_context = AsyncMock()
        session = BrowserSession(context=mock_context, page=mock_page)

        result = await self.worker.test_dom_xss(session, "http://target/page", "search")
        assert result.success is True
        assert len(result.data["findings"]) >= 1
        assert result.data["findings"][0]["type"] == "DOM XSS"

    @pytest.mark.asyncio
    async def test_execute_capture_state(self):
        """execute with capture_state action returns DOM state."""
        dom_state = {"forms": [], "links": [], "scripts": [], "title": "Test", "url": "about:blank"}

        mock_page = AsyncMock()
        mock_page.goto = AsyncMock()
        mock_page.evaluate = AsyncMock(return_value=dom_state)

        mock_context = AsyncMock()
        mock_context.new_page = AsyncMock(return_value=mock_page)
        mock_context.close = AsyncMock()

        mock_browser = AsyncMock()
        mock_browser.new_context = AsyncMock(return_value=mock_context)
        self.worker._browser = mock_browser

        result = await self.worker.execute("about:blank", action="capture_state")
        assert result.success is True
        assert "forms" in result.data

    @pytest.mark.asyncio
    async def test_execute_unknown_action_returns_error(self):
        """Unknown action returns success=False."""
        mock_page = AsyncMock()
        mock_page.goto = AsyncMock()
        mock_page.evaluate = AsyncMock(return_value={})

        mock_context = AsyncMock()
        mock_context.new_page = AsyncMock(return_value=mock_page)
        mock_context.close = AsyncMock()

        mock_browser = AsyncMock()
        mock_browser.new_context = AsyncMock(return_value=mock_context)
        self.worker._browser = mock_browser

        result = await self.worker.execute("about:blank", action="nonexistent")
        assert result.success is False
        assert result.error is not None
