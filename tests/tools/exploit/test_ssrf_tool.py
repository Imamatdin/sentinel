"""Tests for SSRFTool."""
import pytest
from unittest.mock import AsyncMock, MagicMock, patch
from aiohttp import ClientError

from sentinel.tools.exploit.ssrf_tool import SSRFTool, SSRFPayload


class TestSSRFTool:
    def setup_method(self):
        self.tool = SSRFTool()

    def test_payloads_loaded(self):
        assert len(self.tool.PAYLOADS) > 0
        assert any("metadata" in p.url_payload for p in self.tool.PAYLOADS)

    def test_payload_structure(self):
        for p in self.tool.PAYLOADS:
            assert isinstance(p, SSRFPayload)
            assert p.name
            assert p.url_payload
            assert p.detection_method in ("response_content", "timing", "oob")

    def test_tool_name(self):
        assert self.tool.name == "ssrf_exploit"

    @pytest.mark.asyncio
    async def test_execute_no_findings_on_failed_requests(self):
        """All payloads fail (connection refused) → no findings, success=False."""
        mock_cm = AsyncMock()
        mock_cm.__aenter__ = AsyncMock(side_effect=ClientError("connection refused"))
        mock_cm.__aexit__ = AsyncMock(return_value=False)

        mock_session = MagicMock()
        mock_session.get.return_value = mock_cm
        mock_session.post.return_value = mock_cm

        with patch("aiohttp.ClientSession") as mock_session_cls:
            mock_session_cls.return_value.__aenter__ = AsyncMock(return_value=mock_session)
            mock_session_cls.return_value.__aexit__ = AsyncMock(return_value=False)

            result = await self.tool.execute("http://localhost:9999/test", "url")
            assert result.success is False
            assert result.data["findings"] == []

    @pytest.mark.asyncio
    async def test_execute_finds_ssrf_when_indicator_in_body(self):
        """Payload with indicator found in response body → finding recorded."""
        mock_resp = AsyncMock()
        mock_resp.status = 200
        mock_resp.url = "http://target/test?url=http://169.254.169.254/latest/meta-data/"
        mock_resp.headers = {}
        mock_resp.text = AsyncMock(return_value="ami-id: ami-12345")

        with patch("aiohttp.ClientSession") as mock_session_cls:
            mock_cm = AsyncMock()
            mock_cm.__aenter__ = AsyncMock(return_value=mock_resp)
            mock_cm.__aexit__ = AsyncMock(return_value=False)

            mock_session = MagicMock()
            mock_session.get.return_value = mock_cm
            mock_session.post.return_value = mock_cm

            mock_session_cls.return_value.__aenter__ = AsyncMock(return_value=mock_session)
            mock_session_cls.return_value.__aexit__ = AsyncMock(return_value=False)

            result = await self.tool.execute("http://target/test", "url", method="GET")
            assert result.success is True
            assert len(result.data["findings"]) > 0

    @pytest.mark.asyncio
    async def test_execute_returns_tool_output_with_metadata(self):
        """Result always has tool_name and metadata keys."""
        mock_cm = AsyncMock()
        mock_cm.__aenter__ = AsyncMock(side_effect=ClientError("err"))
        mock_cm.__aexit__ = AsyncMock(return_value=False)

        mock_session = MagicMock()
        mock_session.get.return_value = mock_cm
        mock_session.post.return_value = mock_cm

        with patch("aiohttp.ClientSession") as mock_session_cls:
            mock_session_cls.return_value.__aenter__ = AsyncMock(return_value=mock_session)
            mock_session_cls.return_value.__aexit__ = AsyncMock(return_value=False)

            result = await self.tool.execute("http://localhost:9999/test", "url")
            assert result.tool_name == "ssrf_exploit"
            assert "total_payloads_tested" in result.metadata

    @pytest.mark.asyncio
    async def test_custom_payloads_override_defaults(self):
        """Custom payloads replace default PAYLOADS list."""
        custom = [SSRFPayload("custom", "http://custom.internal/", "response_content", "custom_hit")]

        with patch("aiohttp.ClientSession") as mock_session_cls:
            mock_resp = AsyncMock()
            mock_resp.status = 200
            mock_resp.url = "http://target/?url=http://custom.internal/"
            mock_resp.headers = {}
            mock_resp.text = AsyncMock(return_value="custom_hit found")

            mock_cm = AsyncMock()
            mock_cm.__aenter__ = AsyncMock(return_value=mock_resp)
            mock_cm.__aexit__ = AsyncMock(return_value=False)

            mock_session = MagicMock()
            mock_session.get.return_value = mock_cm
            mock_session_cls.return_value.__aenter__ = AsyncMock(return_value=mock_session)
            mock_session_cls.return_value.__aexit__ = AsyncMock(return_value=False)

            result = await self.tool.execute(
                "http://target/", "url", custom_payloads=custom
            )
            assert result.metadata["total_payloads_tested"] == 1
            assert result.success is True
