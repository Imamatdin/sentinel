"""Tests for XXETool."""
import pytest
from unittest.mock import AsyncMock, MagicMock, patch

from sentinel.tools.exploit.xxe_tool import XXETool


class TestXXETool:
    def setup_method(self):
        self.tool = XXETool()

    def test_payloads_loaded(self):
        assert len(self.tool.PAYLOADS) >= 4
        assert "classic_file_read" in self.tool.PAYLOADS
        assert "classic_windows" in self.tool.PAYLOADS

    def test_tool_name(self):
        assert self.tool.name == "xxe_exploit"

    def test_payloads_contain_xml(self):
        for name, payload in self.tool.PAYLOADS.items():
            assert isinstance(payload, str)
            assert len(payload) > 0

    @pytest.mark.asyncio
    async def test_execute_no_findings_on_error(self):
        """All requests fail → no findings, success=False."""
        with patch("aiohttp.ClientSession") as mock_session_cls:
            mock_session = AsyncMock()
            mock_session_cls.return_value.__aenter__ = AsyncMock(return_value=mock_session)
            mock_session_cls.return_value.__aexit__ = AsyncMock(return_value=False)
            mock_session.request.side_effect = Exception("connection error")

            result = await self.tool.execute("http://localhost:9999/xml")
            assert result.success is False
            assert result.data["findings"] == []
            assert result.tool_name == "xxe_exploit"

    @pytest.mark.asyncio
    async def test_execute_detects_etc_passwd_in_response(self):
        """When response contains 'root:' → finding confirmed."""
        mock_resp = AsyncMock()
        mock_resp.status = 200
        mock_resp.text = AsyncMock(return_value="root:x:0:0:root:/root:/bin/bash\ndaemon:x:1:1")

        mock_cm = AsyncMock()
        mock_cm.__aenter__ = AsyncMock(return_value=mock_resp)
        mock_cm.__aexit__ = AsyncMock(return_value=False)

        mock_session = MagicMock()
        mock_session.request.return_value = mock_cm

        with patch("aiohttp.ClientSession") as mock_session_cls:
            mock_session_cls.return_value.__aenter__ = AsyncMock(return_value=mock_session)
            mock_session_cls.return_value.__aexit__ = AsyncMock(return_value=False)

            result = await self.tool.execute("http://target/xml-endpoint")
            assert result.success is True
            assert len(result.data["findings"]) > 0
            assert result.data["findings"][0]["indicator"] in ["root:", "daemon:"]

    @pytest.mark.asyncio
    async def test_execute_returns_http_traces(self):
        """Metadata always includes http_traces even with no findings."""
        mock_resp = AsyncMock()
        mock_resp.status = 200
        mock_resp.text = AsyncMock(return_value="<response>ok</response>")

        mock_cm = AsyncMock()
        mock_cm.__aenter__ = AsyncMock(return_value=mock_resp)
        mock_cm.__aexit__ = AsyncMock(return_value=False)

        mock_session = MagicMock()
        mock_session.request.return_value = mock_cm

        with patch("aiohttp.ClientSession") as mock_session_cls:
            mock_session_cls.return_value.__aenter__ = AsyncMock(return_value=mock_session)
            mock_session_cls.return_value.__aexit__ = AsyncMock(return_value=False)

            result = await self.tool.execute("http://target/xml-endpoint")
            assert "http_traces" in result.metadata
            assert len(result.metadata["http_traces"]) == len(self.tool.PAYLOADS)
